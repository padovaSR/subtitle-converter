#!/usr/bin/env python
# -*- coding: UTF-8 -*-
#
#  Copyright (C) 2020  padovaSR
#
#   This program is free software: you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation, either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# generated by wxGlade 0.9.9pre
#
import os
import sys
import srt
import re
import shutil
import pickle
import zipfile
from collections import namedtuple
from operator import itemgetter
from io import BytesIO
from pydispatch import dispatcher
from itertools import chain
from more_itertools import unique_justseen
from Manual import MyManual
from zip_confirm import TreeDialog 
from errors_check import checkErrors, checkChars, checkFile, displayError
from File_processing import newName, nameDialog, writeToFile
from File_Handler import fileHandle, addPrevious
from file_settings import FileSettings
from merger_settings import Settings
from fixer_settings import FixerSettings
from file_dnd import FileDrop
from merge import myMerger, FixSubGaps
from zamenaImena import shortcutsKey 
from interactive_replace import FindReplace 
from settings import BYTES_TEXT as BT
from settings import (
    filePath,
    baseName, 
    PREVIOUS,
    FILE_HISTORY,
    WORK_TEXT, 
    FILE_SETTINGS,
    name_data,
    log_file_history,
    printEncoding,
    droppedText, 
)

from text_processing import (
    ConvertText,
    ChangeEncoding,
    rm_dash, 
    fixI,
    rplStr,
    bufferText,
    codelist,
    normalizeText,
    remTag,
    preLatin,
    cleanUp,
    cleanLine,
    doReplace,
    zameniImena, 
)

import logging
import logging.config

from subtitle_converter_gui import ConverterFrame
import wx.lib.agw.shortcuteditor as SE
import wx

logging.config.fileConfig(
    "resources/var/log/mainlog.ini", disable_existing_loggers=False
)
logger = logging.getLogger(__name__)


VERSION = "v0.5.9.0_alpha14"


class MyFrame(ConverterFrame):
    def __init__(self, *args):
        ConverterFrame.__init__(self, *args)
        
        self.SetTitle(f"SubtitleConverter {VERSION}")

        self.wildcard = (
            "SubRip (*.zip; *.srt; *.txt)|*.zip;*.srt;*.txt|MicroDVD" "\
            (*.sub)|*.sub|Text File (*.txt)|*.txt|All Files (*.*)|*.*"
        )

        with open(filePath('resources', 'var', 'dialog_settings.db.dat'), "rb") as s:
            data = pickle.load(s)
            ex = data['key4']
            new_font = ex['new_font']
            fontSize = int(ex['fontSize'])
            fC = ex['fontColour']
            bl = ex['weight']

        if bl == 92:
            weight = wx.FONTWEIGHT_BOLD
        else:
            weight = wx.FONTWEIGHT_NORMAL

        self.text_1.SetFont(
            wx.Font(
                fontSize,
                wx.FONTFAMILY_DEFAULT,
                wx.FONTSTYLE_NORMAL,
                weight,
                0,
                new_font,
            )
        )
        self.curFont = self.text_1.GetFont()
        self.curClr = wx.Colour((fC[0], fC[1], fC[2], fC[3]))
        self.text_1.SetForegroundColour(self.curClr)
        self.text_1.SetFont(self.curFont)
        self.curClr = self.text_1.GetForegroundColour()
        self.updateUI()

        self.dont_show = False
        self.hideDialog = False
        self.multiFile = False

        self.bytesText = BytesIO()
        
        self.utf8_latText = {}

        self.location = "tmp"
        self.cyrUTF = r""
        self.pre_suffix = r""
        self.newEnc = ""
        
        self.tmpPath = []
        self.real_path = []
        self.real_dir = r""
        self.cyrUTFmulti = []
        self.find = []

        ## Undo-Redo ######################
        self.UNDO_A = []
        self.REDO_A = []
        
        self.UndoText = []
        self.RedoText = []
        ###################################

        self.sc = {}
        self.fsize = {}

        self.filehistory = wx.FileHistory()
        self.filehistory.UseMenu(self.file_sub)
        self.filehistory.AddFilesToMenu()

        self.menu_items = [
            self.cleaner,
            self.cyr_to_ansi,
            self.cyr_to_utf,
            self.export_zip,
            self.fixer,
            self.merger,
            self._regex,
            self.specials,
            self.to_ansi,
            self.to_cyrillic,
            self.to_utf8,
            self.transcrib,
            self.change, 
        ]

        ## MENU EVENTS ##############################################################################
        self.Bind(wx.EVT_MENU, self.onOpen, id=self.fopen.GetId())
        self.Bind(wx.EVT_MENU, self.onReload, id=self.reload.GetId())
        self.Bind(wx.EVT_MENU, self.onSave, id=self.save.GetId())
        self.Bind(wx.EVT_MENU, self.onSaveAs, id=self.save_as.GetId())
        self.Bind(wx.EVT_MENU, self.exportZIP, id=self.export_zip.GetId())
        self.Bind(wx.EVT_MENU, self.onCloseFile, id=self.close.GetId())
        self.Bind(wx.EVT_MENU, self.onQuit, id=self.quit_program.GetId())
        #############################################################################################
        # self.Bind(wx.EVT_MENU, self.clearUndoRedo, id=self.clear.GetId())
        self.Bind(wx.EVT_MENU, self.onReloadText, id=self.reloadtext.GetId())
        self.Bind(wx.EVT_MENU, self.onUndo, id=self.undo.GetId())
        self.Bind(wx.EVT_MENU, self.onRedo, id=self.redo.GetId())
        self.Bind(wx.EVT_MENU, self.undoAction, id=self.undo_action.GetId())
        self.Bind(wx.EVT_MENU, self.redoAction, id=self.redo_action.GetId())
        #############################################################################################
        self.Bind(wx.EVT_MENU, self.toCyrillic, id=self.to_cyrillic.GetId())
        self.Bind(wx.EVT_MENU, self.toANSI, id=self.to_ansi.GetId())
        self.Bind(wx.EVT_MENU, self.toUTF, id=self.to_utf8.GetId())
        self.Bind(wx.EVT_MENU, self.onTranscribe, id=self.transcrib.GetId())
        self.Bind(wx.EVT_MENU, self.ChangeManualy, id=self.change.GetId())
        self.Bind(wx.EVT_MENU, self.onRepSpecial, id=self.specials.GetId())
        self.Bind(wx.EVT_MENU, self.onCleanup, id=self.cleaner.GetId())
        self.Bind(wx.EVT_MENU, self.applyRegex, id=self._regex.GetId())
        self.Bind(wx.EVT_MENU, self.onCyrToANSI, id=self.cyr_to_ansi.GetId())
        self.Bind(wx.EVT_MENU, self.onCyrToUTF, id=self.cyr_to_utf.GetId())
        self.Bind(wx.EVT_MENU, self.onMergeLines, id=self.merger.GetId())
        #############################################################################################
        self.Bind(wx.EVT_MENU, self.utfSetting, id=-1)
        self.Bind(wx.EVT_MENU, self.showLog, id=-1)
        self.Bind(wx.EVT_MENU, self.editShortcuts, id=self.shortcuts.GetId())
        self.Bind(wx.EVT_MENU, self.onAbout, id = self.about.GetId())
        self.Bind(wx.EVT_MENU, self.onManual, id=self.manual.GetId())
        self.Bind(wx.EVT_MENU, self.onFixerSettings, id=self.fixer.GetId())
        self.Bind(wx.EVT_MENU, self.onSelectFont, id=self.fonts.GetId())
        self.Bind(wx.EVT_MENU, self.onFileSettings, id=83)
        self.Bind(wx.EVT_MENU, self.onMergerSettings, id=self.merger_pref.GetId())        
        ## TOOLBAR EVENTS ###########################################################################
        self.Bind(wx.EVT_TOOL, self.onOpen, id=1001)
        self.Bind(wx.EVT_TOOL, self.onSave, id=1010)
        self.Bind(wx.EVT_TOOL, self.toCyrillic, id=1002)
        self.Bind(wx.EVT_TOOL, self.toANSI, id=1003)
        self.Bind(wx.EVT_TOOL, self.toUTF, id=1004)
        self.Bind(wx.EVT_TOOL, self.onTranscribe, id=1005)
        self.Bind(wx.EVT_TOOL, self.onRepSpecial, id=1006)
        self.Bind(wx.EVT_TOOL, self.onCleanup, id=1007)
        self.Bind(wx.EVT_TOOL, self.onQuit, id=1008)
        self.searchCtrl1.Bind(wx.EVT_SEARCHCTRL_SEARCH_BTN, self.searchText, id=self.searchCtrl1.GetId())
        self.searchCtrl1.Bind(wx.EVT_TEXT, self.searchChange, id=self.searchCtrl1.GetId())
        ## Events other #############################################################################
        self.text_1.Bind(wx.EVT_TEXT, self.removeFiles, id=-1, id2=wx.ID_ANY)
        self.text_1.Bind(wx.EVT_TEXT, self.writeText, self.text_1)
        # self.text_1.Bind(wx.EVT_LEFT_DOWN, self.newText, id=wx.ID_ANY)
        self.text_1.Bind(wx.EVT_TEXT_ENTER, self.newText, id=wx.ID_ANY)
        self.Bind(
            wx.EVT_MENU_RANGE, self.onFileHistory, id=wx.ID_FILE1, id2=wx.ID_FILE9,
        )
        self.comboBox1.Bind(wx.EVT_COMBOBOX, self.onChoice, id=-1, id2=wx.ID_ANY)
        self.Bind(wx.EVT_MENU, self.toCyrUTF8, id=82)
        self.Bind(wx.EVT_SIZE, self.size_frame, id=-1)
        self.Bind(wx.EVT_CLOSE, self.onClose, id=wx.ID_ANY)
        #############################################################################################
        self.text_1.Bind(wx.EVT_CHAR, self.EvtChar, id=wx.ID_ANY)
        self.text_1.Bind(wx.EVT_KEY_DOWN, self.EvtKey, id=wx.ID_ANY)
        #############################################################################################
        entries = [wx.AcceleratorEntry() for i in range(2)]
        entries[0].Set(wx.ACCEL_CTRL | wx.ACCEL_SHIFT, ord('Y'), 82)
        entries[1].Set(wx.ACCEL_CTRL | wx.ACCEL_SHIFT, ord('F'), 83)
        accel_tbl = wx.AcceleratorTable(entries)
        self.SetAcceleratorTable(accel_tbl)
        #############################################################################################
        ## drop target
        dt = FileDrop(self.text_1)
        self.text_1.SetDropTarget(dt)
        ##=========================================================================================##
        FILE_SETTINGS["CB_value"] = self.comboBox1.GetValue()
        
        for i in FILE_HISTORY:
            if os.path.isfile(i):
                self.filehistory.AddFileToHistory(i)
            else: FILE_HISTORY.remove(i)
        ##=========================================================================================##
        self.disableTool()

        dispatcher.connect(self.updateStatus, signal="TMP_PATH", sender=dispatcher.Any)
        dispatcher.connect(self.enKode, signal="TMP_PATH", sender=dispatcher.Any)
        dispatcher.connect(self.updateText, signal="DIALOG", sender=dispatcher.Any)
        
    def updateStatus(self, message, msg):
        ''''''
        self.enableTool()
        self.clearUndoRedo()
        
        if msg[2] is True:
            self.multiFile = True
            self.SetStatusText('Multiple files ready for processing')
            self.SetStatusText("", 1)
        else:
            path = message
            enc = printEncoding(msg[1])
            if type(path) is list:
                path = path[-1]
            self.filehistory.AddFileToHistory(FILE_HISTORY[len(FILE_HISTORY)-1])
            self.SetStatusText(baseName(path))
            self.SetStatusText(enc, 1)
            self.tmpPath = [path]
            self.real_dir = os.path.dirname(msg[0])
            logger.debug(f"Droped <updateStatus> real_dir: {self.real_dir}")
        nlist = checkErrors(self.text_1.GetValue())
        if nlist:
            for i in nlist:
                self.text_1.SetStyle(i[0], i[1], wx.TextAttr("BLUE", "YELLOW"))
                self.text_1.SetInsertionPoint(i[1])

    def enKode(self, message, msg):

        self.enableTool()
        self.clearUndoRedo()

        rlPath = msg[0]
        logger.debug(f"Droped <enKode> real_path: {rlPath}")
        tpath = message
        if type(tpath) is list:
            tpath = tpath[-1]
        enc = msg[1]

        self.real_dir = os.path.dirname("".join(rlPath))

        self.real_path = [rlPath]
        if enc == "windows-1251":
            self.to_ansi.Enable(False)
            self.frame_toolbar.EnableTool(1003, False)

    def updateUI(self):
        self.curClr = wx.BLACK
        with open(filePath('resources', 'var', 'dialog_settings.db.dat'), "rb") as s:
            data = pickle.load(s)
            ex = data['key4']
            new_font = ex['new_font']
            fontSize = int(ex['fontSize'])
            fC = ex['fontColour']
            bl = ex['weight']

        if bl == 92:
            weight = wx.FONTWEIGHT_BOLD
        else:
            weight = wx.FONTWEIGHT_NORMAL

        self.text_1.SetFont(
            wx.Font(
                fontSize,
                wx.FONTFAMILY_DEFAULT,
                wx.FONTSTYLE_NORMAL,
                weight,
                0,
                new_font,
            )
        )

        self.curClr = wx.Colour((fC[0], fC[1], fC[2], fC[3]))
        self.text_1.SetFont(self.curFont)
        self.text_1.SetForegroundColour(self.curClr)
    
    def updateText(self, message):
        """"""
        text = WORK_TEXT.getvalue()
        self.text_1.SetValue(text)
        for x in set(message):
            ctext = re.compile(r"\b"+x+r"\b")
            for m in re.finditer(ctext, self.text_1.GetValue()):
                self.text_1.SetStyle(m.start(), m.end(), wx.TextAttr(wx.RED, wx.YELLOW))        
                self.text_1.SetInsertionPoint(m.end())

    def enableTool(self):

        self.frame_toolbar.EnableTool(wx.ID_CLOSE, True)

        ## 1002=toCyrillic, 1003=toANSI, 1004=toUTF
        ## 1005=Transcribe, 1006=Special, 1007=Cleanup

        for i in [1002, 1003, 1004, 1005, 1006, 1007]:
            self.frame_toolbar.EnableTool(i, True)

        for i in self.menu_items:
            if not i.IsEnabled(): i.Enable(True)
            
        if PREVIOUS:
            if PREVIOUS[0].enc == "windows-1251":
                self.to_ansi.Enable(False)
                self.frame_toolbar.EnableTool(1003, False)
            for i in [self.save, self.save_as]:
                if not i.IsEnabled():
                    if not PREVIOUS[-1].action.endswith("multiple"):
                        if baseName(self.fromPrevious("Open")[5]) in [
                            "Untitled.srt",
                            "Untitled.txt",
                        ]:
                            self.save.Enable()
                            self.save_as.Enable()
                            self.frame_toolbar.EnableTool(1010, True)  ## 1010=Save

    def disableTool(self):

        self.frame_toolbar.EnableTool(wx.ID_CLOSE, False)

        ## 1010=Save, 1002=toCyrillic, 1003=toANSI,
        ## 1004=toUTF, 1005=Transcribe, 1006=Special, 1007=Cleanup
        id_list = [1010, 1002, 1003, 1004, 1005, 1006, 1007]
        for i in id_list:
            self.frame_toolbar.EnableTool(i, False)

        new_items = [
            self.save,
            self.save_as,
            self.reload,
            self.undo,
            self.redo,
            self.undo_action,
            self.redo_action,
            self.reloadtext,
        ]

        for i in new_items: i.Enable(False)
        for t in self.menu_items: t.Enable(False)

    def multipleTools(self):

        self.disableTool()
        for i in [1002, 1003, 1004]:
            self.frame_toolbar.EnableTool(i, True)
        for i in [
            self.to_cyrillic,
            self.to_utf8,
            self.cyr_to_ansi,
            self.cyr_to_utf,
            self.export_zip,
            self.to_ansi, 
        ]:
            i.Enable(True)

    def postAction(self, path):

        path = self.fStatus(path)
        self.SetStatusText(path)
        self.SetStatusText(printEncoding(self.newEnc), 1)

        for i in [wx.ID_SAVE, wx.ID_SAVEAS, wx.ID_CLOSE]:
            self.menubar1.Enable(i, True)
        
        for i in [self.reload, self.undo_action, self.redo_action, self.reloadtext]:
            i.Enable(True)

        self.frame_toolbar.EnableTool(1010, True)  # Save

        if not self.REDO_A: self.redo_action.Enable(False)

        if (
            any([PREVIOUS[-1].action == x for x in ("toCYR", "toCyrUTF8")])
            or self.newEnc == "windows-1251"
        ):
            self.frame_toolbar.EnableTool(1003, False)
            self.to_ansi.Enable(False)

    def newText(self, event):
        """"""
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and not PREVIOUS and len(tval) > 40:
            try:
                text = self.text_1.GetValue()
                place = self.text_1.GetInsertionPoint()
                self.tmpPath.clear()
                self.real_path.clear()
                self.real_path.append(filePath(os.getcwd(), "Untitled.txt"))
                PREVIOUS.clear()
                addPrevious(
                    "Open",
                    "utf-8",
                    text,
                    "",
                    "tmp/Untitled.txt",
                    filePath(os.getcwd(), "Untitled.txt"),
                )
                self.text_1.SetInsertionPoint(place)
                self.tmpPath.append("tmp/Untitled.txt")
                self.real_dir = os.getcwd()
                self.newEnc = "utf-8"
                self.SetStatusText("Untitled.txt")
                self.SetStatusText("UTF-8", 1)
                self.enableTool()
                self.undo.Enable()
            except Exception as e:
                logger.debug(f"newText: {e}")
        event.Skip()

    def onOpen(self, event):
        ''''''
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        dlgOpen = wx.FileDialog(
            self,
            "Otvori novi fajl",
            style=wx.FD_OPEN | wx.FD_MULTIPLE,
            wildcard=self.wildcard,
        )
        if dlgOpen.ShowModal() == wx.ID_OK:
            self.tmpPath.clear()
            self.real_path.clear()
            PREVIOUS.clear()
            self.clearUndoRedo()
            filepath = dlgOpen.GetPaths()  # Get the file location
            if len(filepath) == 1:
                real_path = "".join(filepath)
                self.real_path.append(real_path)
                self.real_dir = os.path.dirname(real_path)
            else:
                for fpath in filepath:
                    self.real_path.append(fpath)
                self.real_dir = os.path.dirname(self.real_path[-1])
            dlgOpen.Destroy()

            fileHandle(filepath, self.text_1)
            
            ## If Open -> multiple files:
            if BT:
                self.real_path.clear()
                self.tmpPath.clear()
                self.SetStatusText(f"Multiple files ready for processing")
                self.SetStatusText("", 1)
                self.enableTool()
                self.multipleTools()
            if PREVIOUS:
                l = self.fromPrevious("Open")
                self.tmpPath.append(l.tpath)
                self.SetStatusText(baseName(l.tpath))
                self.SetStatusText(printEncoding(l.enc), 1)
                self.enableTool()

        event.Skip()

    def onReload(self, event):
        
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        if PREVIOUS:
            if zipfile.is_zipfile(self.real_path[0]):
                zfile = zipfile.ZipFile(self.real_path[0])
                if len(zfile.namelist()) >= 2:
                    self.clearUndoRedo()
                    self.reload.Enable(False)
                    self.reloadtext.Enable(False)
                    return
            if self.real_path:
                fileHandle(self.real_path, self.text_1)
                self.pre_suffix = ""
                path = self.fromPrevious("Open")[4]
                enc = self.fromPrevious("Open")[1]
                self.pre_suffix = ""
                self.clearUndoRedo()
                if len(self.real_path) > 1:
                    self.real_path.clear()
                    self.real_path.append(self.fromPrevious("Open")[5])
                logger.debug(f'Reloaded {baseName(path)}, encoding: {enc}')
                self.SetStatusText(printEncoding(enc), 1)        
            else:
                self.reload.Enable(False)
                return
        event.Skip()
        
    def onReloadText(self, event):
        ''''''
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        if PREVIOUS:
            path = self.fromPrevious("Open")[4]
            if os.path.isfile(droppedText):
                with open(droppedText, 'rb') as f:
                    d = pickle.load(f)
                text = list(d.items())[0][0]
                enc = list(d.items())[0][1]
                self.text_1.SetValue(text)
                bufferText(text, WORK_TEXT)
            else:
                text = self.fromPrevious("Open")[2]
                enc = self.fromPrevious("Open")[1]
                self.text_1.SetValue(text)
                bufferText(text, WORK_TEXT)
                
            self.REDO_A.clear() 
            logger.debug(f'Text reloaded from: {baseName(path)}; {enc}')
            
            self.SetStatusText(printEncoding(enc), 1)
            self.clearUndoRedo()
            addPrevious("Open", enc, text, self.pre_suffix, path, self.real_path[-1])
            self.enableTool()
        event.Skip()

    def onSave(self, event):
        
        tpath, enc = self.PathEnc()
        if tpath and enc:
            fname, nsuffix = newName(tpath, self.pre_suffix)
            # Puna putanja sa imenom novog fajla
            outpath = nameDialog(fname, nsuffix, self.real_dir)
            if outpath:
                if self.text_1.IsModified(): text = self.text_1.GetValue()
                else: text = WORK_TEXT.getvalue()
                if not text: text = self.fromPrevious("Open")[2]
                
                v = writeToFile(text, outpath, enc, ask=True)
                if os.path.isfile(outpath) and v is True:
                    logger.debug(f"File saved: {outpath}")
                    fpath = baseName(outpath)
                    sDlg = wx.MessageDialog(
                        self,
                        "Fajl je uspešno sačuvan\n{}".format(fpath),
                        'SubtitleConverter',
                        wx.OK | wx.ICON_INFORMATION
                    )
                    sDlg.ShowModal()
                    FILE_HISTORY.append(outpath)
                    self.filehistory.AddFileToHistory(outpath)                
                    self.reload.Enable(True)
                    self.reloadtext.Enable(True)
                    self.SetStatusText(baseName(outpath))
                elif v is True and not os.path.isfile(outpath):
                    dlg = wx.MessageDialog(
                        self,
                        "Greška\n\nTekst nije sačuvan",
                        "SubtitleConverter",
                        wx.OK | wx.ICON_ERROR,
                    )
                    dlg.ShowModal()
        event.Skip()

    def onSaveAs(self, event):
        
        sas_wildcard = "SubRip (*.srt)|*.srt|MicroDVD (*.sub)|*.sub|Text File\
        (*.txt)|*.txt|All Files (*.*)|*.*"
        real_dir = self.real_dir
        dlg = wx.FileDialog(
            self,
            message="Save file as ...",
            defaultDir=real_dir,
            defaultFile="",
            wildcard=sas_wildcard,
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
        )
        try:
            if self.real_path:
                name = baseName(self.real_path[-1])
                fname, nsuffix = newName(name, self.pre_suffix, multi=False)
                fname = fname + nsuffix
            else:
                fname = 'Untitled.txt'
        except IndexError as e:
            logger.debug("Save file - IndexError({0}):".format(e))
        except Exception as e:
            logger.debug(f"Save file - error: {e}")
        dlg.SetFilename(fname)
        if dlg.ShowModal() == wx.ID_OK:
            path = dlg.GetPath()
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            if not text: text = text = self.fromPrevious("Open")[2]
            
            v = writeToFile(text, path, self.newEnc, multi=False)
            if os.path.isfile(path) and v is True:
                logger.debug(f"File saved sucessfully. {path}")
                sDlg = wx.MessageDialog(
                    self,
                    'Fajl je uspešno sačuvan\n{}'.format(
                        baseName(path)
                    ),
                    'SubtitleConverter',
                    wx.OK | wx.ICON_INFORMATION,
                )
                sDlg.ShowModal()
                FILE_HISTORY.append(path)
                self.filehistory.AddFileToHistory(path)
                self.reload.Enable(True)
        else:
            dlg.Destroy()
        event.Skip()

    def toCyrillic(self, event):

        with open(
            filePath("resources", "var", "dialog_settings.db.dat"), "rb"
        ) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['cyr_ansi_srt']
            value2_s = ex['cyr_utf8_txt']
        
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()
        
        if self.preferences.IsChecked(1011):  
            utf8_enc = 'utf-8-sig'
        else: utf8_enc = 'utf-8'        
        
        if len(BT) >= 1:
            self.multipleTools()
            self.toCyrillic_multiple()

        else:
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            
            self.newEnc = 'windows-1251'
            self.pre_suffix = value1_s
            
            self.utf8_latText[baseName(path)] = (
                remTag(text)
                .encode(encoding="utf-8", errors="surrogatepass")
                .replace(b"\n", b"\r\n")
            )
            if text: text = text.replace('?', '¬')

            utf_name, suffix = newName(path, value2_s, multi=False)
            utf_path = filePath(self.real_dir, (utf_name + suffix))
            
            pvalue = self.preferences.IsChecked(1014)
            if pvalue is True: text = preLatin(text_in=text)
            
            text, msg = ConvertText(text).changeLetters(preProc=pvalue)
            
            cyr_path = path
            self.cyrUTF = utf_path
            
            writeToFile(text, utf_path, utf8_enc, ask=True)
            
            text_ansi = ConvertText(text).toCyrANSI(self.newEnc)
            
            error_text = checkFile(path, cyr_path, text_ansi)
            text_ansi = displayError(
                text, self.text_1, self.real_dir, path, self.newEnc,
            )
            
            bufferText(text_ansi, WORK_TEXT)
            self.bytesToBuffer(text_ansi, self.newEnc)
            
            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                
            addPrevious(
                "toCYR",
                self.newEnc,
                text.replace("¬", "?"),
                self.pre_suffix,
                path,
                self.real_path[-1],
            )
            self.postAction(path)
            
        event.Skip()

    def toCyrillic_multiple(self):

        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value1_s = ex['cyr_ansi_srt']
            value2_s = ex['cyr_utf8_txt']

        if self.preferences.IsChecked(1011):
            utf8_enc = 'utf-8-sig'
        else: utf8_enc = 'utf-8'        
        
        self.newEnc = 'windows-1251'
        self.pre_suffix = value1_s
        f_text = ["Files Processed:\n\n"]

        self.tmpPath.clear()
        self.cyrUTFmulti.clear()
        
        pvalue = self.preferences.IsChecked(1014)
        self.utf8_latText.clear()
        
        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)
            
            file_suffix = os.path.splitext(path)[-1]
            
            text = normalizeText(entered_enc, None, text)
            
            self.utf8_latText[baseName(path)] = (
                remTag(text)
                .encode(encoding="utf-8", errors="surrogatepass")
                .replace(b"\n", b"\r\n")
            )
            if text: text = text.replace('?', '¬')

            utfText, suffix = newName(path, value2_s, multi=True)

            utf_path = filePath(self.real_dir, utfText + suffix)
            self.cyrUTFmulti.append(utf_path)

            text, msg = ConvertText(text).changeLetters(preProc=pvalue)
            
            writeToFile(text, utf_path, utf8_enc, multi=True)
            
            cyr_name, cyr_suffix = newName(path, value1_s, multi=True)
            cyr_path = filePath(self.real_dir, cyr_name + file_suffix)
            
            self.tmpPath.append(cyr_path)
            
            text_ansi = ConvertText(text).toCyrANSI(self.newEnc)
            
            error_text = checkFile(utf_path, cyr_path, text_ansi, multi=True)
            text = displayError(
                text_ansi,
                self.text_1,
                self.real_dir,
                cyr_path,
                self.newEnc,
                multi=True,
            )
            
            writeToFile(text, cyr_path, self.newEnc, multi=True)
            
            f_text.append(baseName(cyr_path)+"    \n")

            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                self.Error_Text = error_text

            self.SetStatusText(baseName(cyr_path))
            
        self.displayText(intext=f_text)
    
        addPrevious("toCYR_multiple", self.newEnc, "", file_suffix, "", "")
        self.SetStatusText('Multiple files done.')
        self.SetStatusText(self.newEnc, 1)
        self.multipleTools()
        self.frame_toolbar.EnableTool(1003, False)
        self.to_ansi.Enable(False)

    def toANSI(self, event):
        
        with open(filePath("resources", "var", "dialog_settings.db.dat"), "rb") as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value4_s = ex['lat_ansi_srt']

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()
        
        if len(BT) >= 1:
            self.multipleTools()
            self.toANSI_multiple()
        else:
            self.newEnc = 'windows-1250'
            self.pre_suffix = value4_s

            if entered_enc == self.newEnc:
                logger.debug(f"toANSI, ecoding is already: {entered_enc}")
                InfoDlg = wx.MessageDialog(
                    self,
                    f"Tekst je već enkoding {entered_enc.upper()}.\nNastaviti?",
                    "SubtitleConverter",
                    style=wx.OK
                    | wx.CANCEL
                    | wx.CANCEL_DEFAULT
                    | wx.ICON_INFORMATION,
                )
                if InfoDlg.ShowModal() == wx.ID_CANCEL:
                    return
                else:
                    InfoDlg.Destroy()

            def ansiAction(inpath):
                
                if entered_enc != 'windows-1251':
                    logger.debug(f'toANSI: {baseName(inpath)}, {entered_enc}')

                if self.text_1.IsModified(): text = self.text_1.GetValue()
                else: text = WORK_TEXT.getvalue()
                
                text = text.replace('?', '¬')
                text = fixI(text)
                text,msg = rplStr(text)
                text = ChangeEncoding(text).toANSI(self.newEnc)
                error_text = checkFile(inpath, inpath, text)
                text = displayError(
                    text, self.text_1, self.real_dir, inpath, self.newEnc
                )

                self.bytesToBuffer(text, self.newEnc)
                self.tmpPath.append(inpath)
                if text:
                    msginfo = wx.MessageDialog(
                        self,
                        f'Tekst će biti sačuvan kao: {self.newEnc.upper()}.',
                        'SubtitleConverter',
                        wx.OK | wx.ICON_INFORMATION,
                    )
                    msginfo.ShowModal()
                    bufferText(text, WORK_TEXT)
                    
                return text, error_text

            def postAnsi():
                self.SetStatusText(self.fStatus(path))
                self.SetStatusText(self.newEnc, 1)
                for i in [wx.ID_SAVE, wx.ID_SAVEAS, wx.ID_CLOSE]:
                    self.menubar1.Enable(i, True)
                self.reload.Enable(True)
                self.frame_toolbar.EnableTool(1010, True)  # Save
                self.frame_toolbar.EnableTool(101, True)
                for i in [self.undo_action, self.redo_action, self.reloadtext, self.reload]:
                    i.Enable(True)
                addPrevious("toANSI", self.newEnc, text, self.pre_suffix, path, self.real_path[-1])
                
            def dialog1(text_1):
                ErrorDlg = wx.MessageDialog(
                    self,
                    text_1,
                    "SubtitleConverter",
                    style=wx.OK
                    | wx.CANCEL
                    | wx.CANCEL_DEFAULT
                    | wx.ICON_INFORMATION,
                )
                if ErrorDlg.ShowModal() == wx.ID_OK:
                    return True

            text = self.text_1.GetValue()
            zbir_slova, procent, chars = checkChars(text, path)
            ertext = "Greška:\n\nTekst sadrži ćiriliči alfabet.\n\n{}\n{}\n\nNastaviti?\n"
            
            if zbir_slova > 1000 and procent >= 90:
                err_text =\
                "Greška:\n\nTekst sadrži ćiriliči alfabet.\n\n{0} procenta teksta:\n[{1}...]\n"\
                .format(procent, ",".join(chars)[:34])
                ErrorDlg = wx.MessageDialog(
                    self, err_text, "SubtitleConverter", style=wx.OK | wx.ICON_ERROR,
                )
                if ErrorDlg.ShowModal() == wx.ID_OK:
                    ErrorDlg.Destroy()
                    self.to_ansi.Enable(False)
                    self.frame_toolbar.EnableTool(1003, False)
                    return            

            ##=====================================================================================##
            if zbir_slova == 0 and procent == 0:
                text, error_text = ansiAction(path)
                if error_text:
                    ErrorDlg = wx.MessageDialog(
                        self,
                        error_text,
                        "SubtitleConverter",
                        wx.OK | wx.ICON_ERROR,
                    )
                    ErrorDlg.ShowModal()
                    self.Error_Text = error_text
                postAnsi()
            ##=====================================================================================##
            elif procent > 0:
                self.SetStatusText(u'Greška u tekstu.')
                f_procent = f'Najmanje {procent} % teksta.\nIli najmanje [ {zbir_slova} ] znakova.'
                ErrorText = ertext.format(f_procent, ",".join(chars))
                dlg = dialog1(ErrorText)
                if dlg is True:
                    if procent >= 50:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            "Too many errors!\n\nAre you sure you want to proceed?\n",
                            "SubtitleConverter",
                            style=wx.CANCEL
                            | wx.CANCEL_DEFAULT
                            | wx.OK
                            | wx.ICON_ERROR,
                        )
                        if ErrorDlg.ShowModal() == wx.ID_CANCEL:
                            return
                    text, error_text = ansiAction(path)
                    if error_text:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            error_text,
                            "SubtitleConverter",
                            wx.OK | wx.ICON_ERROR,
                        )
                        ErrorDlg.ShowModal()
                        self.Error_Text = error_text
                    postAnsi()
            ##=====================================================================================##
            elif zbir_slova > 0:
                f_zbir = 'Najmanje [ {} ] znakova.'.format(zbir_slova)
                ErrorText = ertext.format(f_zbir, ",".join(chars))
                self.SetStatusText(u'Greška u tekstu.')
                dlg = dialog1(ErrorText)
                if dlg is True:
                    text, error_text = ansiAction(path)
                    if error_text:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            error_text,
                            "SubtitleConverter",
                            wx.OK | wx.ICON_ERROR,
                        )
                        ErrorDlg.ShowModal()
                        self.Error_Text = error_text
                    postAnsi()
        event.Skip()

    def toANSI_multiple(self):

        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value4_s = ex['lat_ansi_srt']

        self.tmpPath.clear()
        f_text = ["Files Processed:\n\n"]
        
        self.newEnc = 'windows-1250'
        self.pre_suffix = value4_s
        
        ErTxt = "Greška:\n\n{0}\nsadrži ćiriliči alfabet.\n{1}\n{2}\n\nNastaviti?\n"
        
        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)
            fpath = baseName(path)
            
            if entered_enc == 'windows-1251':
                logger.debug(
                    f"------------------------------------------------------\n\
                Encoding is windows-1251! {fpath}"
                )
                f_text.append(fpath + " __skipped_"+"    \n")
                continue

            text = normalizeText(entered_enc, None, text)
            
            zbir_slova, procent, chars = checkChars(text, path)

            def ansiAction(path, text_in):
                if entered_enc != 'windows-1251':
                    logger.debug(
                        'ToANSI, next input encoding: {}'.format(entered_enc)
                    )
                try:
                    if not text_in:
                        text_in = (
                            f"{path}\nText is not SRT format.\nTry as single file."
                        )
                    if text_in:
                        text = text_in.replace('?', '¬')
                    text = fixI(text)
                    text,msg = rplStr(text)
                    text = ChangeEncoding(text).toANSI(self.newEnc)
                    nam, b = newName(path, self.pre_suffix, multi=True)
                    newF = filePath(self.real_dir, nam + b)
                    self.tmpPath.append(newF)
                    return newF, text
                except Exception as e:
                    logger.debug(f"{baseName(path)}: {e}")
                    
            def postAnsi():
                self.SetStatusText(baseName(newF))
                self.SetStatusText(self.newEnc, 1)
                
            def dialog1(text_1):
                ErrorDlg = wx.MessageDialog(
                    self,
                    text_1,
                    "SubtitleConverter",
                    style=wx.OK
                    | wx.CANCEL
                    | wx.CANCEL_DEFAULT
                    | wx.ICON_INFORMATION,
                )
                if ErrorDlg.ShowModal() == wx.ID_OK:
                    return True

            if zbir_slova == 0 and procent == 0:
                newF, text = ansiAction(path, text)

                error_text = checkFile(path, newF, text, True)

                text = displayError(
                    text, self.text_1, self.real_dir, path, self.newEnc, multi=True,
                )
                writeToFile(text, newF, self.newEnc, True)

                f_text.append(baseName(newF)+"    \n")
                if error_text:
                    ErrorDlg = wx.MessageDialog(
                        self, error_text, "SubtitleConverter", wx.OK | wx.ICON_ERROR,
                    )
                    ErrorDlg.ShowModal()
                postAnsi()

            elif procent > 0:
                logger.debug(
                    f'ToANSI: Cyrillic alfabet u tekstu: {entered_enc} cyrillic'
                )
                self.SetStatusText(u'Greška u ulaznom fajlu.')
                f_procent = f"Najmanje {procent} % teksta.\nIli najmanje [ {zbir_slova} ] znakova"
                dlg = dialog1(
                    ErTxt.format(baseName(path), f_procent, ",".join(chars))
                )
                if dlg is True:
                    if procent >= 50:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            "Too many errors!\n\nAre you sure you want to proceed?\n",
                            "SubtitleConverter",
                            style=wx.CANCEL | wx.CANCEL_DEFAULT | wx.OK | wx.ICON_ERROR,
                        )
                        if ErrorDlg.ShowModal() == wx.ID_CANCEL:
                            continue
                    newF, text = ansiAction(path, text)
                    error_text = checkFile(path, newF, text, True)

                    text = displayError(
                        text, self.text_1, self.real_dir, path, self.newEnc, True,
                    )
                    writeToFile(text, newF, self.newEnc, True)

                    f_text.append(baseName(newF)+"    \n")
                    if error_text:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            error_text,
                            "SubtitleConverter",
                            wx.OK | wx.ICON_ERROR,
                        )
                        ErrorDlg.ShowModal()
                    postAnsi()

            elif zbir_slova > 0:
                logger.debug(
                    f'ToANSI: Cyrillic alfabet u tekstu: {entered_enc} cyrillic'
                )
                f_zbir = f"Najmanje [ {zbir_slova} ] znakova."
                dlg = dialog1(
                    ErTxt.format(baseName(path), f_zbir, ",".join(chars))
                )

                if dlg is True:
                    newF, text = ansiAction(path, text)
                    error_text = checkFile(path, path, text, multi=True)

                    f_text.append(baseName(newF)+"    \n")

                    text = displayError(
                        text, self.text_1, self.real_dir, path, self.newEnc, True,
                    )
                    writeToFile(text, newF, self.newEnc, multi=True)

                    if error_text:
                        ErrorDlg = wx.MessageDialog(
                            self,
                            error_text,
                            "SubtitleConverter",
                            wx.OK | wx.ICON_ERROR,
                        )
                        ErrorDlg.ShowModal()
                    postAnsi()
                    
        self.displayText(intext=f_text)
        addPrevious("toANSI_multiple", self.newEnc, "", self.pre_suffix, "", "")
        self.SetStatusText('Multiple files done.')
        self.multipleTools()

    def toCyrUTF8(self, event):
        ''''''
        with open(
            filePath("resources", "var", "dialog_settings.db.dat"), "rb"
        ) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value_s = ex["cyr_utf8_srt"]

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return

        path, entered_enc = self.PathEnc()

        if self.preferences.IsChecked(1011):
            utf8_enc = 'utf-8-sig'
        else: utf8_enc = 'utf-8'
        
        if len(BT) >= 1:
            self.multipleTools()
            self.toCyrUTF8_multiple()

        else:
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            
            self.newEnc = utf8_enc
            self.pre_suffix = value_s
            
            if text: text = text.replace('?', '¬')

            utf_name, suffix = newName(path, value_s, multi=False)
            utf_path = filePath(self.real_dir, (utf_name + suffix))
            
            pvalue = self.preferences.IsChecked(1014)
            if pvalue is True: text = preLatin(text_in=text)
            
            text = ChangeEncoding(text).toUTF_8(self.newEnc)
            text, msg = ConvertText(text).changeLetters(preProc=pvalue)
            cyr_path = path
            self.cyrUTF = utf_path

            error_text = checkFile(path, cyr_path, text)
            text = displayError(text, self.text_1, self.real_dir, path, self.newEnc)
            
            bufferText(text, WORK_TEXT)
            
            self.bytesToBuffer(text, self.newEnc)

            writeToFile(text, utf_path, utf8_enc, ask=True)
            
            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                
            addPrevious(
                "toCyrUTF8",
                self.newEnc,
                text,
                self.pre_suffix,
                path,
                self.real_path[-1],
            )
            
            self.postAction(path)
                
        event.Skip()
        
    def toCyrUTF8_multiple(self):
        """"""
        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value_s = ex["cyr_utf8_srt"]

        if self.preferences.IsChecked(1011):  
            utf8_enc = 'utf-8-sig'
        else: utf8_enc = 'utf-8'        
        
        self.newEnc = utf8_enc
        self.pre_suffix = value_s
        f_text = ["Files Processed:\n\n"]

        self.tmpPath.clear()
        self.cyrUTFmulti.clear()
        
        pvalue = self.preferences.IsChecked(1014)
        
        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)
            
            file_suffix = os.path.splitext(path)[-1]

            text = normalizeText(entered_enc, None, text)
            if not text:
                text = f"{path}\nText nije SRT format.\nPokušaj pojedinačni fajl."
            if text: text = text.replace('?', '¬')

            utfText, suffix = newName(path, value_s, multi=True)

            utf_path = filePath(self.real_dir, utfText + suffix)
            self.cyrUTFmulti.append(utf_path)
            
            text = ChangeEncoding(text).toUTF_8(self.newEnc)
            text,msg = ConvertText(text).changeLetters(preProc=pvalue)
            
            cyr_name, cyr_suffix = newName(path, value_s, multi=True)
            cyr_path = filePath(self.real_dir, cyr_name + file_suffix)

            self.tmpPath.append(cyr_path)

            error_text = checkFile(utf_path, cyr_path, text, multi=True)
            text = displayError(
                text,
                self.text_1,
                self.real_dir,
                cyr_path,
                self.newEnc,
                multi=True,
            )

            writeToFile(text, utf_path, self.newEnc, multi=True)
            f_text.append(baseName(cyr_path) + "    \n")

            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self, error_text, "SubtitleConverter", wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                self.Error_Text = error_text

            self.SetStatusText(baseName(cyr_path))
        
        self.displayText(intext=f_text)
        
        self.SetStatusText(printEncoding(self.newEnc), 1)
        addPrevious("toCyrUTF8_multiple", self.newEnc, "", file_suffix, "", "")
        self.SetStatusText('Multiple files done.')
        self.multipleTools()
        
    def toUTF(self, event):

        with open(filePath("resources", "var", "dialog_settings.db.dat"), "rb") as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['lat_utf8_srt']

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return

        path, entered_enc = self.PathEnc()

        if len(BT) >= 1:
            self.multipleTools()
            self.toUTF_multiple()
        else:
            cyr_utf = ""
            if PREVIOUS:
                cyr_utf = PREVIOUS[len(PREVIOUS) - 2].action

            self.pre_suffix = value1_s

            if self.preferences.IsChecked(1011):
                self.newEnc = 'utf-8-sig'
            else: self.newEnc = 'utf-8'

            if (
                entered_enc == "utf-8"
                or entered_enc == "utf-8-sig"
                and cyr_utf != "toCYR"
            ):
                code = printEncoding(entered_enc)
                logger.debug(f"toUTF: Encoding is {entered_enc}.")

            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            
            text = ChangeEncoding(text).toUTF_8(new_enc=self.newEnc)
            text = fixI(text)
            self.text_1.SetValue(text)

            if text:
                code = printEncoding(self.newEnc)

                bufferText(text, WORK_TEXT)
                self.bytesToBuffer(text, self.newEnc)

                msginfo = wx.MessageDialog(
                    self,
                    f'Tekst će biti sačuvan kao: {code}.',
                    'SubtitleConverter',
                    wx.OK | wx.ICON_INFORMATION,
                )
                msginfo.ShowModal()

            self.SetStatusText(code, 1)
            addPrevious(
                "toUTF", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
            )
            self.postAction(path)

        event.Skip()
    def toUTF_multiple(self):
        
        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value1_s = ex["lat_utf8_srt"]

        self.tmpPath.clear()
        self.pre_suffix = value1_s

        if self.preferences.IsChecked(1011):
            self.newEnc = 'utf-8-sig'
        else: self.newEnc = 'utf-8'
        entered_enc = ""
        f_text = ["Files Processed:\n\n"]

        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)
            
            text = normalizeText(entered_enc, None, text)
            if not text: text = f"{path}\nText is not SRT format.\nTry as single file."
            if text: text = text.replace('?', '¬')

            nam, b = newName(path, self.pre_suffix, multi=True)
            newF = '{0}{1}'.format(filePath(self.real_dir, nam), b)
            fproc = ChangeEncoding(text)
            text = fproc.toUTF_8(self.newEnc)
            text = fixI(text)
            self.tmpPath.append(newF)  # VAZNO
            
            error_text = checkFile(path, newF, text, multi=True)

            text = displayError(
                text,
                self.text_1,
                self.real_dir,
                newF,
                self.newEnc,
                multi=True,
            )

            writeToFile(text, newF, self.newEnc, multi=True)

            f_text.append(baseName(newF)+"    \n")
            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
            self.SetStatusText(baseName(newF))
        
        self.displayText(intext=f_text)
        self.multipleTools()
        if entered_enc == "windows-1251":
            self.frame_toolbar.EnableTool(1003, False)
            self.to_ansi.Enable(False)
            msginfo = wx.MessageDialog(
                self,
                f'Novi fajl: {self.newEnc} Ćirilica.',
                'SubtitleConverter',
                wx.OK | wx.ICON_INFORMATION,
            )
            msginfo.ShowModal()
        
        addPrevious("toUTF_multiple", self.newEnc, "", self.pre_suffix, "", "")
        self.SetStatusText('Multiple files done.')
        self.SetStatusText(printEncoding(self.newEnc), 1)

    def onCyrToANSI(self, event):

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        with open(filePath("resources","var","dialog_settings.db.dat"), "rb",) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['lat_ansi_srt']

        path, entered_enc = self.PathEnc()

        if len(BT) >= 1:
            self.multipleTools()
            self.cyrToANSI_multiple()
        else:
            self.pre_suffix = value1_s

            self.newEnc = 'windows-1250'
            
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            
            if text: text = text.replace('?', '¬')
                
            pvalue = self.preferences.IsChecked(1014)
            text, msg = ConvertText(text).changeLetters(pvalue, True)
            cyr_path = path
            
            text = ChangeEncoding(text).toANSI(self.newEnc)
            
            error_text = checkFile(path, cyr_path, text, multi=False)
            text = displayError(
                text,
                self.text_1,
                self.real_dir,
                cyr_path,
                self.newEnc,
                multi=False,
            )

            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                self.Error_Text = error_text

            bufferText(text, WORK_TEXT)
            self.bytesToBuffer(text, self.newEnc)
            
            if os.path.exists(self.cyrUTF):
                os.remove(self.cyrUTF)
            
            addPrevious(
                "cyrToANSI",
                self.newEnc,
                text,
                self.pre_suffix,
                path,
                self.real_path[-1],
            )
            self.postAction(path)
        event.Skip()
    
    def cyrToANSI_multiple(self):

        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value1_s = ex["lat_ansi_srt"]
        
        self.tmpPath.clear()
        self.pre_suffix = value1_s
        self.newEnc = 'windows-1250'
        
        f_text = ["Files Processed:\n\n"]
        
        pvalue = self.preferences.IsChecked(1014)

        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)

            try:
                text = normalizeText(entered_enc, None, text)
                
                if text: text = text.replace('?', '¬')
                
                text, msg = ConvertText(text).changeLetters(pvalue, True)
                
                nam, b = newName(path, self.pre_suffix, True)
                newF = '{0}{1}'.format(filePath(self.real_dir, nam), b)

                f_text.append(baseName(newF)+"    \n")
                self.tmpPath.append(newF)
                
                text = ChangeEncoding(text).toANSI(self.newEnc)
                
                error_text = checkFile(path, newF, text, multi=True)
                text = displayError(
                    text,
                    self.text_1,
                    self.real_dir,
                    newF,
                    self.newEnc,
                    multi=True,
                )

                writeToFile(text, newF, self.newEnc, multi=True)

                if error_text:
                    ErrorDlg = wx.MessageDialog(
                        self,
                        error_text,
                        "SubtitleConverter",
                        wx.OK | wx.ICON_ERROR,
                    )
                    ErrorDlg.ShowModal()
                    self.Error_Text = error_text
                self.SetStatusText(f"Processing {baseName(newF)}")
            except Exception as e:
                logger.debug(f"cyrToANSI error: {e}")
        
        self.displayText(intext=f_text)
        self.multipleTools()
        addPrevious("cyrToANSI_multiple", self.newEnc, "", self.pre_suffix)
        self.SetStatusText('Multiple files done.')
        self.SetStatusText(self.newEnc, 1)
        
    def onCyrToUTF(self, event):

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        with open(
            filePath("resources", "var", "dialog_settings.db.dat"), "rb"
        ) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['lat_utf8_srt']
        
        path, entered_enc = self.PathEnc()
        
        if len(BT) >= 1:
            self.multipleTools()
            self.cyrToUTF_multiple()
        else:        
                
            self.pre_suffix = value1_s
            
            if self.preferences.IsChecked(1011):
                self.newEnc = 'utf-8-sig'
            else:
                self.newEnc = 'utf-8'
            
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
                    
            if text: text = text.replace('?', '¬')
            
            pvalue = self.preferences.IsChecked(1014)
                    
            text, msg = ConvertText(text).changeLetters(pvalue, True)
            cyr_path = path
            
            text = ChangeEncoding(text).toUTF_8(self.newEnc)
            
            error_text = checkFile(path, cyr_path, text, multi=False)
            text = displayError(
                text,
                self.text_1,
                self.real_dir,
                cyr_path,
                self.newEnc,
                multi=False,
            )

            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                self.Error_Text = error_text

            bufferText(text, WORK_TEXT)
            self.bytesToBuffer(text, self.newEnc)
            
            if os.path.exists(self.cyrUTF):
                os.remove(self.cyrUTF)
                        
            addPrevious(
                "cyrToUTF", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
            )
            self.postAction(path)
        event.Skip()
        
    def cyrToUTF_multiple(self):
        
        with open(
            filePath("resources", "var", "file_ext.pkl"), "rb"
        ) as f:
            ex = pickle.load(f)  # ["key5"]
            value1_s = ex["lat_utf8_srt"]

        f_text = ["Files Processed:\n\n"]
        
        self.pre_suffix = value1_s
        self.tmpPath.clear()

        if self.preferences.IsChecked(1011):
            self.newEnc = 'utf-8-sig'
        else: self.newEnc = 'utf-8'

        pvalue = self.preferences.IsChecked(1014)
        
        for i in range(len(BT)):
            path, entered_enc, text = self.getPathEnc(i)
            
            text = normalizeText(entered_enc, None, text)
            if not text: text = f"{path}\nText is not SRT format.\nTry as single file." 
            if text: text = text.replace('?', '¬')

            nam, b = newName(path, self.pre_suffix, True)
            newF = '{0}{1}'.format(filePath(self.real_dir, nam), b)

            text, msg = ConvertText(text).changeLetters(pvalue, True)
            
            text = ChangeEncoding(text).toUTF_8(self.newEnc)

            error_text = checkFile(path, newF, text, multi=True)
            text = displayError(
                text,
                self.text_1,
                self.real_dir,
                newF,
                self.newEnc,
                multi=True,
            )

            f_text.append(baseName(newF)+"    \n")
            self.tmpPath.append(newF)

            writeToFile(text, newF, self.newEnc, multi=True)

            if error_text:
                ErrorDlg = wx.MessageDialog(
                    self,
                    error_text,
                    "SubtitleConverter",
                    wx.OK | wx.ICON_ERROR,
                )
                ErrorDlg.ShowModal()
                self.Error_Text = error_text
            self.SetStatusText(baseName(path))
            
        self.displayText(intext=f_text)
        self.multipleTools()
        self.SetStatusText(printEncoding(self.newEnc), 1)
        addPrevious("cyrToUTF_multiple", self.newEnc, "", self.pre_suffix)
        self.SetStatusText('Multiple files done.')
        
    def onFixSubs(self):

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()

        if len(BT) >= 1: return

        try:
            with open(
                filePath('resources', 'var', 'dialog_settings.db.dat'), "rb",
            ) as sp:
                data = pickle.load(sp)
                ex = data['key1']
                cb1_s = ex['fixgap']
                cb8_s = ex['nuliranje']
                _gap = ex["mingap"]
                fx = data['key5']
                value1_s = fx['fixed_subs']
        except Exception as e:
            logger.debug(f"FixSubtitle error: {e}")

        self.pre_suffix = value1_s
        self.newEnc = entered_enc
        
        if self.text_1.IsModified(): text = self.text_1.GetValue()
        else: text = WORK_TEXT.getvalue()
                
        subs = list(srt.parse(text, ignore_errors=True))

        if len(subs) == 0:
            logger.debug("Fixer: No subtitles found.")
        else:
            text = ""
            if cb1_s is True:
                if cb8_s != True:
                    m = 0
                    s1 = 0
                    while True:
                        subs = list(srt.parse(WORK_TEXT.getvalue(), ignore_errors=True))
                        x, y = FixSubGaps(inlist=subs, mingap=_gap).powerSubs()
                        m += x
                        s1 += y
                        if x == 0:
                            break
                else: logger.debug("Fixer: Remove gaps not enabled.")
            try:
                if not cb8_s:
                    text = srt.compose(srt.parse(WORK_TEXT.getvalue(), ignore_errors=True))
                else:
                    text = WORK_TEXT.getvalue()
            except Exception as e:
                logger.debug(f"FixSubtitle, unexpected error: {e}")

            text = rm_dash(text)

            bufferText(text, WORK_TEXT)
            self.text_1.SetValue(text)

            self.bytesToBuffer(text, entered_enc)
            
            if cb1_s is True:
                if cb8_s != True:
                    if s1 > 1:
                        m1 = f'\nPreklopljenih linija: [ {s1} ]'
                        logger.debug(m1)
                    else:
                        m1 = ''
                    logger.debug(f'Fixer: Popravljenih gapova: {m}')
                    if m >= 0:
                        sDlg = wx.MessageDialog(
                            self,
                            f'Subtitle fix\n\nPopravljenih gapova: [ {m} ]\n{m1}',
                            'SubtitleConverter',
                            wx.OK | wx.ICON_INFORMATION,
                        )
                        sDlg.ShowModal()

        addPrevious(
            "FixSubtitle", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
        )
        self.postAction(path)
        
    def onCleanup(self, event):
        
        with open(
            filePath("resources", "var", "dialog_settings.db.dat"), "rb",
        ) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['cleanup']

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()

        if len(BT) >= 1: return

        self.newEnc = entered_enc
        self.pre_suffix = value1_s

        if self.text_1.IsModified():
            text = self.text_1.GetValue()
        else: text = WORK_TEXT.getvalue()
            
        try:
            subs = list(srt.parse(text, ignore_errors=True))
            NUM1 = len(subs)
            subs = srt.compose(subs)
            
            text = cleanUp(subs)

            N2, text_s = cleanLine(text)
            
            text = cleanUp(text_s)
            
            D2, text_s = cleanLine(text)            

            bufferText(text_s, WORK_TEXT)
            self.text_1.SetValue(text_s)
            logger.debug(f"CleanUp _1: {sys.exc_info()}")

            self.bytesToBuffer(text_s, entered_enc)
            
            if D2 ==0 and N2 == 0:
                msginfo = wx.MessageDialog(
                    self,
                    'Subtitle clean\nno changes made.',
                    'SubtitleConverter',
                    wx.OK | wx.ICON_INFORMATION,
                )
                msginfo.ShowModal()
            else:
                if D2 == 0 and N2 > 0: D2 = N2
                msginfo = wx.MessageDialog(
                    self,
                    f'Subtitles deleted: [{NUM1-D2} ]',
                    'SubtitleConverter',
                    wx.OK | wx.ICON_INFORMATION,
                )
                msginfo.ShowModal()
            
            addPrevious(
                "Cleanup",
                self.newEnc,
                text_s,
                self.pre_suffix,
                path,
                self.real_path[-1],
            )
            self.postAction(path)

        except Exception as e:
            logger.debug(f"Cleanup: {e}")
            return
        
        event.Skip()
        
    def onTranscribe(self, event):
        
        with open(
            filePath("resources", "var", "dialog_settings.db.dat"), "rb",
        ) as sp:
            data = pickle.load(sp)
            ex = data['key5']
            value1_s = ex['transcribe']

        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()

        if len(BT) >= 1:
            return

        self.pre_suffix = value1_s

        if self.preferences.IsChecked(1011):
            self.newEnc = 'utf-8-sig'
        else: self.newEnc = 'utf-8'

        if self.text_1.IsModified(): text = self.text_1.GetValue()
        else: text = WORK_TEXT.getvalue()
            
        if text: text = text.replace('?', '¬')

        text = ChangeEncoding(text).toUTF_8(self.newEnc)
        text = fixI(text)
        
        num, text = zameniImena(text)
        
        if num > 28 or num < 28 and num > 2:
            msginfo = wx.MessageDialog(
                self,
                f'Zamenjenih objekata\nukupno [ {num} ]',
                'SubtitleConverter',
                wx.OK | wx.ICON_INFORMATION,
            )
            msginfo.ShowModal()

        text,msg = rplStr(text)

        error_text = checkFile(path, path, text)

        text = displayError(
                text, self.text_1, self.real_dir, path, self.newEnc,
            )
        
        bufferText(text, WORK_TEXT)
        self.bytesToBuffer(text, self.newEnc)

        if error_text:
            ErrorDlg = wx.MessageDialog(
                self, error_text, "SubtitleConverter", wx.OK | wx.ICON_ERROR,
            )
            ErrorDlg.ShowModal()

            addPrevious(
                "Transcribe", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
            )
                    
        self.postAction(path)

        event.Skip()
        
    def ChangeManualy(self, event):
        """"""
        text = self.text_1.GetValue()
        dlg = FindReplace(None, subtitles=list(srt.parse(text)))
        dlg.ShowModal()
        dlg.Destroy()
        if PREVIOUS:
            l = PREVIOUS[-1]
            addPrevious("ChangeManualy", l.enc, WORK_TEXT.getvalue(), l.psuffix, l.tpath, l.rpath)
            self.newEnc = l.enc
            self.postAction(l.tpath)
        event.Skip()
        
    def onRepSpecial(self, event):
        
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
       
        path, entered_enc = self.PathEnc()

        if len(BT) >= 1:
            return

        self.newEnc = entered_enc
        self.pre_suffix = 'rpl'

        if self.text_1.IsModified(): text = self.text_1.GetValue()
        else: text = WORK_TEXT.getvalue()
        
        text = text.replace('?', '¬')

        num, text_o = doReplace(text)
        
        error_text = checkFile(path, path, text_o, multi=False)
        text_s = displayError(
            text_o, self.text_1, self.real_dir, path, entered_enc, multi=False,
        )

        bufferText(text_s, WORK_TEXT)
        
        self.bytesToBuffer(text_s, entered_enc)
        
        msginfo = wx.MessageDialog(
            self,
            'Zamenjenih objekata\nukupno [ {} ]'.format(num),
            'SubtitleConverter',
            wx.OK | wx.ICON_INFORMATION,
        )
        msginfo.ShowModal()
        if error_text:
            ErrorDlg = wx.MessageDialog(
                self, error_text, "SubtitleConverter", wx.OK | wx.ICON_ERROR
            )
            ErrorDlg.ShowModal()
            self.Error_Text = error_text
        
        self.postAction(path)
        addPrevious(
            "repSpec", self.newEnc, text_s, self.pre_suffix, path, self.real_path[-1]
        )
        
        event.Skip()
        
    def applyRegex(self, event):
        
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()
        self.newEnc = entered_enc

        if len(BT) >= 1:
            return

        self.pre_suffix = "reg"

        if self.text_1.IsModified(): text = self.text_1.GetValue()
        else: text = WORK_TEXT.getvalue()

        d_file = filePath("resources", "Regex_def.config")

        with open(d_file, "r", encoding="utf-8") as f_open:

            reg_1 = re.compile('find=|\'|"', re.I)
            cn = 0

            for line in f_open:

                cn += 1
                if line.startswith("#"):
                    continue
                if not line:
                    continue

                line = line.strip().lower()

                if line and not "replace=" in line:
                    logger.debug(
                        f"Apply Regex, missing argument, line {cn}; {d_file}"
                    )

                x = line.split("replace=")

                finds = re.sub(reg_1, '', x[0]).strip()
                reps = re.sub(reg_1, '', x[-1]).strip()

                if reps:
                    x = reps.split("#")
                    if x[-1]:
                        reps = x[0].strip()

                try:
                    if "ignorecase" in reps:
                        reps = reps.replace("ignorecase", "").strip()
                        rflags = (re.M | re.I)
                        reg_def = re.compile(finds, rflags)
                    else:
                        reg_def = re.compile(finds, re.M)

                    text = reg_def.sub(reps, text)

                except Exception as e:
                    error_text = (
                        f"Regex error\n\n{baseName(d_file)}\n{line}: {cn}\n{e}"
                    )
                    logger.debug(error_text)
                    ErrorDlg = wx.MessageDialog(
                        None, error_text, "SubtitleConverter", wx.OK | wx.ICON_ERROR
                    )
                    ErrorDlg.ShowModal()
                    
        self.text_1.SetValue(text)
        bufferText(text, WORK_TEXT)
        
        self.bytesToBuffer(text, entered_enc)
        
        addPrevious(
            "CustomRegex", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
        )
        self.postAction(path)

        event.Skip()
    
    def onMergeLines(self, event):
        
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return
        
        path, entered_enc = self.PathEnc()  ## path = tmp/

        if len(BT) >= 1:
            return

        self.newEnc = entered_enc  

        try:
            with open(
                filePath('resources', 'var', 'dialog_settings.db.dat'), "rb",
            ) as sp:
                data = pickle.load(sp)
                ex = data['key2']
                lineLenght = ex['l_lenght']
                maxChar = ex['m_char']
                maxGap = ex['m_gap']
                file_suffix = ex['f_suffix']
        except Exception as e:
            logger.debug(f"Merger, unexpected error: {e}")

        try:
            if self.text_1.IsModified(): text = self.text_1.GetValue()
            else: text = WORK_TEXT.getvalue()
            subs_a = list(srt.parse(text, ignore_errors=True))
        except Exception as e:
            logger.debug(f"Merger _1, unexpected error: {e}")

        if subs_a[1].start == subs_a[2].start == "0:00:00,000000":

            msginfo = wx.MessageDialog(
                self,
                'Erroneous subtitle\n\nAll values are zero!',
                'SubtitleConverter',
                wx.OK | wx.ICON_INFORMATION,
            )
            msginfo.ShowModal()
            return

        self.pre_suffix = file_suffix

        if len(subs_a) > 0:

            myMerger(
                subs_in=subs_a, max_time=lineLenght, max_char=maxChar, _gap=maxGap,
            )

            b1 = len(list(srt.parse(WORK_TEXT.getvalue(), ignore_errors=True)))
            a1 = len(subs_a)

            text = WORK_TEXT.getvalue()
            text = srt.compose(srt.parse(text, ignore_errors=True))
            bufferText(text, WORK_TEXT)
            
            self.bytesToBuffer(text, entered_enc)
            self.text_1.SetValue(text)

            try:
                prf = format(((a1 - b1) / a1 * 100), '.2f')
            except ZeroDivisionError as e:
                logger.debug(f"Merger Error: {e}")
            else:
                logger.debug(
                    f"Merger: Spojenih linija ukupno: {a1-b1}, ili {prf} %"
                )
                sDlg = wx.MessageDialog(
                    self,
                    f"Merged file:\n\nSpojenih linija ukupno: {a1-b1}, ili {prf} %",
                    'SubtitleConverter',
                    wx.OK | wx.ICON_INFORMATION,
                )
                sDlg.ShowModal()
            addPrevious(
                "Merger", self.newEnc, text, self.pre_suffix, path, self.real_path[-1]
            )            
            self.postAction(path)
            
        event.Skip()

    def exportZIP(self, event):

        self.PathEnc()

        if len(BT) >= 1:
            self.multipleTools()
            self.exportZIPmultiple()
        else:
            if BT:
                if len(BT) > 1:
                    return
            with open(
                filePath("resources", "var", "dialog_settings.db.dat"), "rb"
            ) as sp:
                data = pickle.load(sp)
                ex = data['key5']
                value_s = ex["lat_utf8_srt"]
                value_c = ex["cyr_ansi_srt"]
            fpath, e = self.PathEnc()
            tpath = baseName(fpath)
            enc = self.newEnc
            sas_wildcard = "ZipArchive (*.zip)|*.zip|All Files (*.*)|*.*"

            if len(PREVIOUS) == 1:
                logger.debug(f"Export Zip: Nothing to do.")
                return
            if PREVIOUS[-1].action == "exportZIP":
                return

            dlg = wx.FileDialog(
                self,
                message="Export file as ZIP",
                defaultDir=self.real_dir,
                defaultFile="",
                wildcard=sas_wildcard,
                style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
            )
            try:
                if fpath:
                    fname, nsufix = newName(tpath, self.pre_suffix, multi=False)
            except Exception as e:
                logger.debug(f"On ZIP error({e})")

            dlg.SetFilename(fname)

            if dlg.ShowModal() == wx.ID_OK:
                path = dlg.GetPath()
                dirname = os.path.dirname(path)
                name = path

                def data_out(buffer, f_path):
                    if f_path:
                        f = open(f_path, 'rb')
                        b_data = f.read()
                        f.close()
                        return b_data
                    if buffer:
                        a_data = buffer.getvalue()
                        if type(a_data) is str:
                            a_data = a_data.encode(enc)
                        a_data = a_data.replace(b"\n", b"\r\n")
                        buffer.seek(0)
                        return a_data

                if PREVIOUS[-1].action == "toCYR":

                    f_enc = self.fromPrevious("Open").enc

                    a, p, l = checkChars(
                        self.fromPrevious("Open").content[0:1000], path, 
                    )
                    if p > 80:
                        dlg = wx.MessageDialog(
                            self,
                            f"Originalni tekst je Ćirilica: {f_enc.upper()}\n{tpath}",
                            'SubtitleConverter',
                            wx.OK | wx.ICON_ERROR,
                        )
                        dlg.ShowModal()

                    if len(PREVIOUS) >= 2:
                        if PREVIOUS[-2].action == "toANSI" or PREVIOUS[-2].enc == "windows-1250":
                            text = PREVIOUS[-2].content
                            text = remTag(text)
                            writeToFile(text, fpath, PREVIOUS[-2].enc, multi=False, ask=True)
                        else:
                            if f_enc in ["utf-8", "utf-8-sig"]:
                                n_enc = "windows-1250"
                            else: n_enc = f_enc
                            text = open(fpath, "r", encoding=f_enc).read()
                            text = remTag(text)
                            writeToFile(text, fpath, n_enc, multi=False, ask=True)                            

                    tUTF = filePath("tmp", baseName(self.cyrUTF)) # cyr_UTF-8
                    try:
                        shutil.copy(self.cyrUTF, tUTF)
                    except Exception as e:
                        logger.debug(f"exportZIP error: {e}")
                        self.text_1.SetValue(f"ERROR\n\nTry different options.\n{e}")
                        return

                    c_name, s = newName(tpath, value_c, False)
                    cyr_file = c_name + s
                    utf8_name, s = newName(tpath, value_s, multi=False)
                    utf8_lat = utf8_name + s
                    info2 = baseName(tUTF)  # cyrUTF-8
                    nname, s = newName(fpath, "", False)
                    info1 = nname + s       # latFile original
                    izbor = [cyr_file, info2, info1, utf8_lat]
                    l = [i for i, x in enumerate(izbor) if izbor.count(x) > 1]
                    if l:
                        n, s = os.path.splitext(izbor[l[1]])
                        izbor[l[1]] = n + "_1_" + s

                    dlg = wx.MultiChoiceDialog(
                        self, 'Pick files:', baseName(name), izbor
                    )
                    if dlg.ShowModal() == wx.ID_OK:
                        response = dlg.GetSelections()
                        files = [izbor[x] for x in response]
                        
                        zdata = data_out(None, fpath)                       ## latFile original
                        tzdata = data_out(None, tUTF)                       ## cyrUTF-8
                        cyrdata = data_out(self.bytesText, None)            ## cyrillic text binary
                        utf8ldata = self.utf8_latText[tpath]                ## latFile utf-8
                        
                        data_v = [cyrdata, tzdata, zdata, utf8ldata]
                        zip_data = [data_v[x] for x in response]
                        if not files:
                            return
                    else:
                        zip_data = []
                        files = []
                        logger.debug("ZIP export: None selected")
                        return
                else:
                    tUTF = ""
                    zip_data = []
                    previous_action = PREVIOUS[-1].action
                    if previous_action == 'toCyrUTF8':
                        zdata = data_out(None, self.cyrUTF)
                        zip_data.append(zdata)
                        info1 = baseName(self.cyrUTF).strip('/')
                        files = [info1]
                        os.remove(self.cyrUTF)
                    elif previous_action == "toUTF":
                        tzdata = data_out(self.bytesText, None)
                        zip_data.append(tzdata)
                        nname, s = newName(fpath, self.pre_suffix, False)
                        files = [nname + s]
                    else:
                        tzdata = data_out(self.bytesText, None)
                        zip_data.append(tzdata)
                        nname, s = newName(fpath, self.pre_suffix, False)
                        files = [nname + s]
                try:
                    with zipfile.ZipFile(name, 'w') as fzip:
                        for i, x in zip(
                            files, zip_data
                            ):
                            if not i:
                                continue
                            if len(x) == 0:
                                continue
                            fzip.writestr(i, x, zipfile.ZIP_DEFLATED)

                except Exception as e:
                    logger.debug(f" Export ZIP error: {e}")

                shutil.move(name, filePath(dirname, name))
                r_files = [tpath, self.cyrUTF, tUTF]
                for i in r_files:
                    if os.path.isfile(i):
                        os.remove(i)
                if os.path.isfile(path):
                    logger.debug(f"ZIP file saved sucessfully: {path}")
                    sDlg = wx.MessageDialog(
                        self,
                        f'Fajl je uspešno sačuvan\n{baseName(path)}',
                        'SubtitleConverter',
                        wx.OK | wx.ICON_INFORMATION,
                    )
                    sDlg.ShowModal()
            else:
                logger.debug(f"Export ZIP: None selected")
                return
        event.Skip()

    def exportZIPmultiple(self):
        ''''''
        tpath = baseName(BT[0].path[:-4])   ## BT=BYTES_TEXT
        epattern = re.compile(r"episode\s*-*\d*", re.I)
        tpath = epattern.sub("", tpath)
        tpath = re.sub(r"(?<=s\d\d)e\d{1,2}", "", tpath, count=1, flags=re.I)
        tpath = (
            tpath.replace(" 1 ", "").replace("x01", "").replace("  ", " ")
        )

        sas_wildcard = "ZipArchive (*.zip)|*.zip|All Files (*.*)|*.*"

        if PREVIOUS[-1].action == "exportZIPmultiple":
            return

        ndata = FILE_SETTINGS["key5"]
        CyrANSI = ndata["Cyr-ansi"]
        CyrUTF = ndata["Cyr-utf8"]
        LatANSI = ndata["Lat-ansi"]
        LatUTF = ndata["Lat-utf8"]
        psuff = ndata["lat_utf8_srt"]
        
        dlg = wx.FileDialog(
            self,
            message="Export file as ZIP",
            defaultDir=self.real_dir,
            defaultFile="",
            wildcard=sas_wildcard,
            style=wx.FD_SAVE | wx.FD_OVERWRITE_PROMPT,
        )

        dlg.SetFilename(tpath)

        def data_out(filein): return open(filein, 'rb').read()
            
        if dlg.ShowModal() == wx.ID_OK:
            name = dlg.GetPath()    ## Zip file name ##
            
            if PREVIOUS[-1].action == 'toCYR_multiple':

                tl = [x.path for x in BT if x.enc in ["utf-8", "utf-8-sig"]]
                if tl:
                    dlg = wx.MessageDialog(
                        self,
                        "Originalni tekstovi su utf-8:\n\n{0}".format(
                            "".join([baseName(x) + "   \n" for x in tl])
                        ),
                        "Latinični tekst",
                        wx.OK | wx.ICON_INFORMATION,
                    )
                    dlg.ShowModal()
                
                innames = []
                info = []
                zlist = []
                izbor_ansi = []
                izbor_utf8 = []
                utf8_names = []
                try:
                    for x in self.utf8_latText.keys():
                        nname, s = newName(x, psuff)
                        utf8_names.append(nname+s)
                    
                    for i, x in zip(self.tmpPath, self.cyrUTFmulti):
    
                        izbor_ansi.append(i)    ## CYR-ANSI 
                        izbor_utf8.append(x)    ## CYR-UTF-8
                        
                    lat_files = [BT[x].path for x in range(len(BT))]
                    
                    zlist_a = [data_out(x) for x in izbor_ansi]
                    zlist_b = [data_out(x) for x in izbor_utf8]
                    zlist_c = [x.content.replace(b"\n", b"\r\n") for x in BT]
                    zlist_utf = [x for x in self.utf8_latText.values()]
                    
                    info1 = [filePath(CyrANSI, baseName(x)) for x in izbor_ansi]
                    info2 = [filePath(CyrUTF, baseName(x)) for x in izbor_utf8]
                    info3 = [filePath(LatANSI, baseName(x)) for x in lat_files]
                    lt_utf8 = [filePath(LatUTF, x) for x in utf8_names]
                
                    innames.extend((info1, info2, info3, lt_utf8))
                    l1=[info1, info2, info3, lt_utf8]
                    l2=[zlist_a, zlist_b, zlist_c, zlist_utf]                    
                except Exception as e:
                    logger.debug(f"ZIP-Cyr: {e}")
                
                if len(self.cyrUTFmulti) == 1:
                    info = [info1+info2+info3+lt_utf8]
                    zlist = [zlist_a+zlist_b+zlist_c+zlist_utf]
                else:
                    cdlg = TreeDialog(
                        self,
                        os.path.dirname(name),
                        baseName(name),
                        innames,
                    )
                    if cdlg.ShowModal() == wx.ID_OK:
                        
                        selections = cdlg.GetSelections()
                        
                        info = list(chain.from_iterable([l1[x] for x in selections]))
                        zlist = list(chain.from_iterable([l2[x] for x in  selections]))
                        
                        if cdlg.makeFolder() is False: info = [baseName(x) for x in info]
                    else:
                        logger.debug(f"ZIP canceled; {baseName(name)}")
                        return
            else:
                zlist = []
                try:
                    izbor = [
                        filePath("tmp", x)
                        if not x.startswith("tmp")
                        else x
                        for x in self.tmpPath
                        if not x.endswith(".zip")
                    ]
                    info = [
                        baseName(x)
                        for x in self.tmpPath
                        if not x.endswith(".zip")
                    ]
                    for i, x in zip(self.tmpPath, izbor):
                        if not os.path.exists(x) and not i.endswith(".zip"):
                            shutil.copy(i, x)
                    zlist = [data_out(x) for x in izbor]
                except Exception as e:
                    logger.debug(f"ExportZIP_A error, {e}")

            if PREVIOUS[-1].action == 'toCyrUTF8_multiple':
                files = self.cyrUTFmulti
                zlist = [data_out(x) for x in files]
                info = [filePath(CyrUTF, baseName(x)) for x in files]
            try:
                with zipfile.ZipFile(name, 'w') as fzip:
                    for i, x in zip(info, zlist):
                        if not i: continue
                        fzip.writestr(i, x, zipfile.ZIP_DEFLATED)
                
                if any(self.tmpPath+self.cyrUTFmulti):
                    for i in self.tmpPath+self.cyrUTFmulti:
                        if os.path.isfile(i): os.remove(i)
                        logger.debug(f"Delete {i}")
            except Exception as e:
                logger.debug(f"Export ZIP_final error: {e}")

            if os.path.isfile(name):
                with zipfile.ZipFile(name) as zf:
                    if len(zf.infolist()) == len(info):
                        logger.debug(f"ZIP file saved sucessfully: {name}")
                        sDlg = wx.MessageDialog(
                            self,
                            f'Zip fajl je uspešno sačuvan\n{baseName(name)}',
                            'SubtitleConverter',
                            wx.OK | wx.ICON_INFORMATION,
                        )
                        sDlg.ShowModal()
                    else:
                        edlg = wx.MessageDialog(
                            self,
                            f"Greška\n\n\
                            Zip nije kompletan\nSačuvanih fajlova: [ {len(zf.infolist())} ]",
                            "SubtitleConverter",
                            wx.OK | wx.ICON_ERROR,
                        )
                        edlg.ShowModal()
        else:
            dlg.Destroy()

    def fStatus(self, path):
        if type(path) is list:
            path = path[-1]
        p, s = os.path.splitext(path)
        if type(self.real_path[0]) is list:
            self.real_path = self.real_path[0]
        suffix = os.path.splitext(self.real_path[0])[-1]
        if s != suffix and suffix != ".zip":
            return f"{baseName(p)}{suffix}"
        else:
            return baseName(path)

    def bytesToBuffer(self, text, enc):
        '''Returns byte'''

        if enc in codelist:
            error = 'surrogatepass'
        else: error = 'replace'
        try:
            self.bytesText.truncate(0)
            self.bytesText.seek(0)
            self.bytesText.write(text.encode(enc, errors=error))
            self.bytesText.seek(0)
            btext = self.bytesText.getvalue()
            self.bytesText.seek(0)

            return btext

        except Exception as e:
            logger.debug(f"bytesToBuffer error: {e}")

    def onClose(self, event):

        with open(filePath("resources", "var", "set_size.pkl"), "wb") as wf:
            pickle.dump(self.fsize, wf)

        self.rwFileHistory(FILE_HISTORY)

        if os.path.isfile(droppedText):
            os.remove(droppedText)

        self.Destroy()

    def onQuit(self, event):
        ''''''
        with open(filePath("resources", "var", "set_size.pkl"), "wb") as wf:
            pickle.dump(self.fsize, wf)

        self.rwFileHistory(FILE_HISTORY)
        if os.path.isfile(droppedText):
            os.remove(droppedText)

        tval = self.text_1.GetValue()

        if (
            not tval.startswith('Files ')
            and len(tval) > 0
            and self.save.IsEnabled()
            and PREVIOUS[-1].action != "toCyrUTF8"
        ):
            dl1 = wx.MessageBox(
                "Current content has not been saved! Proceed?",
                "Please confirm",
                wx.ICON_QUESTION | wx.YES_NO,
                self,
            )
            if dl1 == wx.NO:
                return
            else:
                self.Destroy()
        else:
            self.Destroy()

    def onCloseFile(self, event):
        self.text_1.SetValue('')
        self.disableTool()
        self.UNDO_A.clear()
        self.REDO_A.clear()
        PREVIOUS.clear()
        self.tmpPath.clear()
        self.SetStatusText('Subtitle Converter is ready')
        self.SetStatusText("", 1)
        event.Skip()

    def removeFiles(self, event):
        ''''''
        try:
            file_paths = [filePath("tmp", x) for x in os.listdir("tmp")]
            fileData = {}
            for fname in file_paths:
                fileData[fname] = os.stat(fname).st_mtime
            sortedFiles = sorted(fileData.items(), key=itemgetter(1))
            if sortedFiles:
                delete = len(sortedFiles)-30
                for x in range(0, delete):
                    os.remove(sortedFiles[x][0])
                    logger.debug(f"removed: {sortedFiles[x][0]}")
        except Exception as e:
            logger.debug(f"removeFiles: {e}")
        event.Skip()

    def PathEnc(self):
        '''This function returns path and entered_enc'''
        path = ""
        entered_enc = ""
        if self.tmpPath and not BT:
            path = PREVIOUS[-1].tpath
            entered_enc = PREVIOUS[-1].enc
        return path, entered_enc

    def onFileSettings(self, event):
        settings_dlg = FileSettings(None)
        settings_dlg.ShowModal()
        settings_dlg.Destroy()
        event.Skip()

    def onMergerSettings(self, event):
        settings_dialog = Settings(None, -1, "")
        settings_dialog.ShowModal()
        event.Skip()

    def onFixerSettings(self, event):
        fixer_dlg = FixerSettings(None)
        ret_code = fixer_dlg.ShowModal()
        fixer_dlg.Destroy()
        if ret_code == True:
            self.onFixSubs()
        event.Skip()

    def utfSetting(self, event):

        if self.preferences.IsChecked(1012):
            item_txt = 'txt'
        else:
            item_txt = 'srt'

        name_data[4] = item_txt

        with open(filePath('resources', 'var', 'tcf.pkl'), 'wb') as tf:
            pickle.dump(item_txt, tf)

        if self.preferences.IsChecked(1011):
            item = 'Checked'
        else:
            item = 'NotChecked'

        with open(filePath('resources', 'var', 'bcf.pkl'), 'wb') as fb:
            pickle.dump(item, fb)

        if self.preferences.IsChecked(1014):
            val = True
        else:
            val = False

        with open(filePath("resources", "var", "obs1.pkl"), "wb") as f:
            pickle.dump(val, f)

        event.Skip()

    def showLog(self, event):
        
        if self.preferences.IsChecked(1013):
            ch = True
        else:
            ch = False
        cb3s = filePath('resources', 'var', 'fixer_cb3.data')
        with open(cb3s, 'wb') as p:
            pickle.dump(ch, p)            
        
        event.Skip()

    def onShortcutChanged(self, event):
        
        shortcut = event.GetShortcut()
        newAccel = event.GetAccelerator()
        if newAccel == "Disabled":
            newAccel = ""
        self.sc[shortcut.label] = newAccel
        
        event.Skip()
        
    def editShortcuts(self, event):
        
        dlg = SE.ShortcutEditor(self)
        dlg.FromMenuBar(self)
        dlg.Bind(SE.EVT_SHORTCUT_CHANGED, self.onShortcutChanged)

        if dlg.ShowModal() == wx.ID_OK:
            dlg.ToMenuBar(self)

            shortcutsKey.update([(key, self.sc[key]) for key in self.sc.keys()])

            i_list = list(shortcutsKey.keys())

            with open(
                filePath("resources", "shortcut_keys.cfg"), "r", encoding="utf-8"
            ) as cf:
                new_f = ""
                for line in cf:
                    if any(line.startswith(n) for n in i_list):
                        x = line.split("=")
                        s = f"{x[0].strip()}={shortcutsKey[x[0].strip()]}\n"
                        new_f += s
                    else:
                        new_f += line

            with open(
                filePath("resources", "shortcut_keys.cfg"),
                "w",
                encoding="utf-8",
                newline="\r\n",
            ) as cf:
                cf.write(new_f)
            
            dlg.Destroy()
        
        event.Skip()

    def onSelectFont(self, event):
        data = wx.FontData()
        data.EnableEffects(True)
        data.SetColour(self.curClr)  # set colour
        data.SetInitialFont(self.curFont)

        dlg = wx.FontDialog(self, data)

        if dlg.ShowModal() == wx.ID_OK:
            data = dlg.GetFontData()
            font = data.GetChosenFont()
            colour = data.GetColour()
            bld = font.GetWeight()
            logger.debug(
                'Selected font: "%s", %d points, color %s'
                % (font.GetFaceName(), font.GetPointSize(), colour.Get())
            )

            fdict = {
                'new_font': font.GetFaceName(),
                'fontSize': font.GetPointSize(),
                'fontColour': colour.Get(),
                'weight': bld,
            }

            FILE_SETTINGS["key4"].update(fdict)

            with open(
                filePath('resources', 'var', 'dialog_settings.db.dat'), "wb"
            ) as s:
                pickle.dump(FILE_SETTINGS, s)

            self.curFont = font
            self.curClr = colour
            self.updateUI()
            # Don't destroy the dialog until you get everything you need from the dialog
        dlg.Destroy()
        event.Skip()

    def size_frame(self, event):

        width, height = event.GetSize()

        self.fsize["W"] = width
        self.fsize["H"] = height

        event.Skip()

    def fromPrevious(self, action):
        """"""
        try:
            return next(x for x in PREVIOUS if x.action == action)
        except StopIteration:
            logger.debug("fromPrevious; StopIteration")

    def getPathEnc(self, n):
        """"""
        return BT[n].path, BT[n].enc, BT[n].content
        
    def rwFileHistory(self, hfile):
        """"""
        logfile = open(log_file_history, "w", encoding="utf-8", newline="\r\n")
        file_set = list(unique_justseen(hfile))
        if len(file_set) > 12:
            file_set = file_set[-12:]
        for paths in file_set:
            if os.path.exists(paths):
                logfile.write(paths + "\n")
        logfile.close()

    def onFileHistory(self, event):
        ''''''
        tval = self.text_1.GetValue()
        if not tval.startswith('Files ') and len(tval) > 0 and self.save.IsEnabled():
            if self.ShowDialog() is False:
                return

        # get the file based on the menu ID
        fileNum = event.GetId() - wx.ID_FILE1
        path = self.filehistory.GetHistoryFile(fileNum)
        if not os.path.exists(path):
            logger.debug(f"FileHistory: not found {path}")
            return
        
        self.tmpPath.clear()
        BT.clear()
        self.real_path.clear()
        
        # add it back to the history so it will be moved up the list
        self.filehistory.AddFileToHistory(path)
        self.real_path.append(path)
        self.real_dir = os.path.dirname(path)
        fileHandle([path], self.text_1)

        self.pre_suffix = PREVIOUS[0].psuffix
        enc = PREVIOUS[0].enc
        self.enableTool()
        self.clearUndoRedo()
        self.tmpPath.append(PREVIOUS[0].tpath)
        logger.debug(f"From FileHistory: {baseName(path)}; {enc}")
        if zipfile.is_zipfile(self.tmpPath[0]):
            self.SetStatusText(baseName(self.tmpPath[0]))
        else:
            self.SetStatusText(baseName(self.tmpPath[0]))
        self.SetStatusText(printEncoding(enc), 1)
        event.Skip()

    def clearUndoRedo(self):
        '''CLear Undo-Redo history'''
        self.RedoText.clear()
        self.UndoText.clear()
        self.UNDO_A.clear()
        self.REDO_A.clear()
        for i in [self.undo_action, self.redo_action]:
            i.Enable(False)

    def undoAction(self, event):
        '''Undo text'''
        
        path = self.tmpPath[0]
        actions = [x.action for x in PREVIOUS]
        if PREVIOUS:
            self.REDO_A.append(PREVIOUS[-1])
        else:
            return
        if not "Open" in actions:
            prev_items = PREVIOUS.pop(len(PREVIOUS) - 2)
        else:
            if PREVIOUS[-1].action == "Open" and len(PREVIOUS) == 2:
                PREVIOUS.reverse()
            prev_items = PREVIOUS[len(PREVIOUS) - 2]
            if len(PREVIOUS) > 2:
                PREVIOUS.pop()

        entered_enc = prev_items.enc
        
        if prev_items:
            text = prev_items.content
            bufferText(text, WORK_TEXT)
            self.text_1.SetValue(text)

        if self.cyrUTF:
            if os.path.exists(self.cyrUTF):
                os.remove(self.cyrUTF)

        if len(self.REDO_A) >= 6:
            self.REDO_A = self.REDO_A[1:]

        enc = printEncoding(entered_enc)

        self.postAction(path)
        self.SetStatusText(enc, 1)
        ## None pre_suffix za početni tekst
        self.pre_suffix = prev_items.psuffix
        
        addPrevious(
            prev_items.action,
            entered_enc,
            text,
            self.pre_suffix,
            path,
            self.real_path[-1],
        )
        if prev_items.action != "toCYR":
            self.frame_toolbar.EnableTool(1003, True)  # toANSI
            self.to_ansi.Enable(True)
        if prev_items.action == "Open":
            self.undo_action.Enable(False)

        event.Skip()

    def redoAction(self, event):
        '''Redo text'''

        path = self.tmpPath[0]
        prev = self.REDO_A.pop()

        # actions = [x.action for x in self.REDO_A]

        if prev:
            text = prev.content
            bufferText(text, WORK_TEXT)
            self.text_1.SetValue(text)
        else:
            return

        if prev.action != "toCYR":
            self.frame_toolbar.EnableTool(1003, True)  # toANSI
            self.to_ansi.Enable(True)

        self.postAction(path)
        self.SetStatusText(printEncoding(prev.enc), 1)
        self.pre_suffix = prev.psuffix
        addPrevious(
            prev.action, prev.enc, text, self.pre_suffix, path, self.real_path[-1]
        )

        event.Skip()

    def onUndo(self, event):
        """"""
        if len(self.RedoText) == 0:
            self.addHistory(
                self.text_1.GetInsertionPoint(), self.text_1.GetValue(), self.RedoText)
            
        self.redo.Enable()
        ## UndoText
        if self.UndoText:
            self.UndoText=sorted(set(self.UndoText), key=self.UndoText.index)
            self.RedoText.append(self.UndoText[len(self.UndoText)-1])
            self.text_1.SetValue(self.UndoText[len(self.UndoText)-1].text)
            self.text_1.SetInsertionPoint(
                self.UndoText[len(self.UndoText)-1].position
            )
            if len(self.UndoText) >= 2: self.UndoText = self.UndoText[:-1]
                        
        if not self.UndoText: self.undo.Enable(False)
        if len(self.UndoText) > 62: self.UndoText = self.UndoText[1:]
        self.reloadtext.Enable()
        self.reload.Enable()
        event.Skip()
        
    def onRedo(self, event):
        """"""
        if self.RedoText:
            self.RedoText=sorted(set(self.RedoText), key=self.RedoText.index)
            self.UndoText.append(self.RedoText[-1])
            self.text_1.SetValue(self.RedoText[len(self.RedoText)-1].text)
            self.text_1.SetInsertionPoint(
                self.RedoText[len(self.RedoText)-1].position
            )
            
            self.RedoText = self.RedoText[:-1]
                
        if not self.RedoText: self.redo.Enable(False)
        if len(self.RedoText) > 62: self.RedoText = self.RedoText[1:]
        event.Skip()

    def addHistory(self, position, text, l=[], k=None):
        '''This function creates namedtuple'''
        hist = namedtuple("hist", ["position", "text", "k"])
        l.append(hist(position, text, k))        
        
    def ShowDialog(self):

        if self.dont_show:
            return

        dlg = wx.RichMessageDialog(
            self,
            "Current conten has not been saved! Proceed?",
            "Please confirm!",
            style=wx.OK | wx.CANCEL,
        )
        dlg.ShowCheckBox("Don't show this message again")
        if dlg.ShowModal() == wx.ID_OK:
            if dlg.IsCheckBoxChecked():
                self.dont_show = True
            return True
        else:
            if dlg.IsCheckBoxChecked():
                self.dont_show = True
            return False
    
    def displayText(self, intext=[]):
        """"""
        if self.hideDialog is True:
            return
        dlg = wx.RichMessageDialog(
            self, "".join(intext), "SubtitleConverter", style=wx.OK
        )
        dlg.ShowCheckBox("Sakrij ovaj dijalog")

        if dlg.ShowModal() == wx.ID_OK:
            if dlg.IsCheckBoxChecked():
                self.hideDialog = True
            dlg.Destroy()
            
    def onChoice(self, event):
        
        ctrl = event.GetEventObject()
        value = ctrl.GetValue()
        
        FILE_SETTINGS["CB_value"] = value
        
        with open(filePath('resources', 'var', 'obsE.pkl'), 'wb') as f:
            pickle.dump(value, f)
            
        event.Skip()
            def onAbout(self, event):
        text = '''SubtitleConverter\n\n\
        Jednostavna wxPython aplikacija \n\
        za konvertovanje srt i txt fajlova\n\
        i transkripciju engleskih imena i pojmova.\n\n\
        Program ima ove opcije:\n\
        -Preslovljavanje latinice u ćirilicu i promena kodnog rasporeda. \n\
        -Konvertovanje unikode u ANSI format.\n\
        -Konvertovanje ANSI u unikode.\n\
        -Default izlazni kodeci su cp1250, 1251 i utf-8.\n\
        -Zamena engleskih imena u titlu odgovarajućim iz rečnika.\n\
         Default izlazni kodek je UTF-8.\n\
        -Mogućnost dodavanja novih definicija za transkripciju u rečnicima. \n\
        -Program konvertuje titlove sa ćiriličnim pismom u latinicu.\n\n\
        Autor: padovaSR\n\
        https://github.com/padovaSR\n\
        License: GNU GPL v2'''
        AboutDlg = wx.MessageDialog(
            self, text, f"SubtitleConverter {VERSION}", wx.OK | wx.ICON_INFORMATION
        )
        AboutDlg.ShowModal()
        event.Skip()
        
    def onManual(self, event):
        dlg = MyManual(None)
        dlg.Show()
        event.Skip()        
    
    def EvtKey(self, event):
        """"""
        #keycode = event.GetKeyCode()
        
        #if not self.text_1.GetValue().startswith("Files ") and not any(
            #[keycode == x for x in (306, 307, 308, 311, 314, 315, 316, 317)]
        #):
            #if any(keycode == x for x in [13, 32, 46]):
                #k = keycode
            #else: k = None
            #self.addHistory(
                #self.text_1.GetInsertionPoint(),
                #self.text_1.GetValue(),
                #l=self.UndoText,
                #k=k,
            #)
            #self.UndoText = sorted(set(self.UndoText), key=self.UndoText.index)
            #if (
                #any(self.UndoText[-1].k == x for x in [13, 32, 46])
                #and len(self.UndoText) > 0
            #):
                #for i in self.UndoText:
                    #if i.k != 32:
                        #self.UndoText.remove(i)
            #self.undo.Enable()
        event.Skip()
        
    def EvtChar(self, event):
        ''''''
        keycode = event.GetUnicodeKey()
        # print(keycode)
        #controlDown = event.CmdDown()
        #altDown = event.AltDown()
        #shiftDown = event.ShiftDown()
        
        if self.text_1.IsModified(): self.find = []
            
        if not self.text_1.GetValue().startswith("Files ") and not any(
            [keycode == x for x in (306, 307, 308, 311, 314, 316)]
        ):
            if any(keycode == x for x in [13, 32, 46, 33, 63]):
                k = keycode
            else: k = None
            self.addHistory(
                self.text_1.GetInsertionPoint(),
                self.text_1.GetValue(),
                l=self.UndoText,
                k=k,
            )
            self.UndoText = sorted(set(self.UndoText), key=self.UndoText.index)
            if (
                any(self.UndoText[-1].k == x for x in [13, 32, 46, 33, 63, 317, 315])
                and len(self.UndoText) > 0
            ):
                for i in self.UndoText:
                    if i.k != 32:
                        self.UndoText.remove(i)
            self.undo.Enable()        
        event.Skip()

    def writeText(self, event):
        """"""
        text = self.text_1.GetValue()
        bufferText(text, WORK_TEXT)
        
        event.Skip()
        
    def searchText(self, event):
        """"""
        if not self.find:
            s_text = event.GetString()
            text2 = self.text_1.GetValue()
            new = [(m.start(), m.end()) for m in re.finditer(re.compile(r"\b"+s_text+r"\b"), text2)]
            self.find = iter(new)
        try:
            p = next(self.find)
            self.text_1.SetStyle(p[0], p[1], wx.TextAttr("WHITE", "LIGHT STEEL BLUE"))
            self.text_1.SetInsertionPoint(p[1])
        except StopIteration:
            logger.debug("Iterator exhausted")
            self.find = []
        event.Skip()
        
    def searchChange(self, event):
        """"""
        self.find = []
        self.text_1.SetValue(self.text_1.GetValue())
        event.Skip()
        
class MyApp(wx.App):
    def remOnstart(self):
        
        f_list = [
            "r_text0.pkl",
            "droped0.pkl",
            "'LatCyr.map.cfg",
            "path0.pkl",
            "rpath0.pkl",
            "dialog_settings.db.bak",
            "dialog_settings.db.dir",
            "txt0.pkl"
        ]
        for x in f_list:
            file_path = filePath("resources","var",x)
            if os.path.isfile(file_path):
                os.remove(file_path)

        if not os.path.isdir('tmp'):
            os.mkdir('tmp')

        b_file = filePath("resources","var","presuffix_list.bak")
        if os.path.exists(b_file):
            with open(b_file, "r", encoding="utf-8") as f:
                lines = f.readlines()
            line_set = set(lines)
            out = open(b_file, "w", encoding="utf-8")
            for line in line_set:
                out.write(line)
            out.close()

    def m_files(self):

        v_list = [
            "bcp.pkl",
            "file_ext.pkl",
            "obs1.pkl",
            "presuffix_list.bak",
            "tcf.pkl",
            "bcf.pkl",
            "dialog_settings.db.dat",
            "fixer_cb3.data",
            "m_extensions.pkl",
            "obsE.pkl",
            "set_size.pkl",
        ]
        r_list = ["shortcut_keys.cfg", "Regex_def.config"]
        v_paths = [filePath("resources", "var", x) for x in v_list]
        r_paths = [filePath("resources", x) for x in r_list]
        logs = filePath("resources","var","log","mainlog.ini")
        v_list.append(logs)
        m_list = [x for x in (v_paths + r_paths) if not os.path.isfile(x)]

        if m_list:
            error_text = "File Not Found\n\n{}\nPlease check files!".format(
                "".join([x + '\n' for x in m_list])
            )
            ErrorDlg = wx.MessageDialog(
                None, error_text, "SubConverter", wx.OK | wx.ICON_ERROR
            )
            ErrorDlg.ShowModal()
    
    def OnInit(self):
        self.frame = MyFrame(None, wx.ID_ANY, "")
        self.SetTopWindow(self.frame)
        self.frame.Show()
        self.remOnstart()
        self.m_files()
        return True


if __name__ == "__main__":
    app = MyApp(0)
    app.MainLoop()
